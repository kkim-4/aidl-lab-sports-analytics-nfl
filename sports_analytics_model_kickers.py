# -*- coding: utf-8 -*-
"""Sports_Analytics_Model_Kickers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cqzb8LXVk6yP5-p5chxSEYySaqQLGhNh
"""

from google.colab import drive
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from sklearn.linear_model import LogisticRegression
import matplotlib.pyplot as plt

# Mount Drive
drive.mount('/content/drive')

# Path to your folder
DATA_PATH = '/content/drive/MyDrive/nfl-big-data-bowl-2022/'

from sklearn.ensemble import RandomForestRegressor

# 1. Corrected Geometry Function
def calculate_kick_angle(absolute_yardline):
    """
    Calculates horizontal angle relative to center of uprights.
    Goalposts are at X=120, Y=26.65.
    We assume the ball is snapped from a hash or center (approx Y=26.65).
    """
    # Distance from goal line (endzone is 10 yards deep)
    dist_to_posts = abs(120 - absolute_yardline)
    # Lateral offset (using 18.5ft/2 as a constant for complexity)
    # For simplicity in this baseline, we use the distance-based angle
    return np.degrees(np.arctan(9.25 / (dist_to_posts * 3 + 1e-6)))

def load_and_process_all():
    print("Loading data...")
    plays = pd.read_csv(DATA_PATH + 'plays.csv')
    scouting = pd.read_csv(DATA_PATH + 'PFFScoutingData.csv')
    players = pd.read_csv(DATA_PATH + 'players.csv')

    # Standardize column names (case sensitivity check)
    players.columns = [c[0].lower() + c[1:] if c != 'nflId' else 'nflId' for c in players.columns]

    # Merge datasets
    df = plays.merge(scouting, on=['gameId', 'playId'], how='left')
    df = df.merge(players[['nflId', 'displayName', 'position']], left_on='kickerId', right_on='nflId', how='left')

    # ---------------------------
    # KICKER LOGIC (FG / XP)
    # ---------------------------
    k_df = df[df['specialTeamsPlayType'].isin(['Field Goal', 'Extra Point'])].copy()
    k_df['is_good'] = (k_df['specialTeamsResult'] == 'Kick Attempt Good').astype(int)

    # FIX: Pass only the single required argument
    k_df['kick_angle'] = k_df['absoluteYardlineNumber'].apply(calculate_kick_angle)

    # Baseline for POE
    X_k = k_df[['kickLength']].fillna(k_df['kickLength'].median())
    y_k = k_df['is_good']
    k_model = LogisticRegression().fit(X_k, y_k)
    k_df['expected_prob'] = k_model.predict_proba(X_k)[:, 1]
    k_df['poe'] = k_df['is_good'] - k_df['expected_prob']

    # ---------------------------
    # PUNTER LOGIC
    # ---------------------------
    p_df = df[df['specialTeamsPlayType'] == 'Punt'].copy()
    X_p = p_df[['absoluteYardlineNumber']].fillna(60)
    y_p = p_df['playResult'].fillna(0)
    p_baseline = RandomForestRegressor(n_estimators=50).fit(X_p, y_p)
    p_df['expected_net'] = p_baseline.predict(X_p)
    p_df['fpoe'] = p_df['playResult'] - p_df['expected_net']

    return k_df, p_df, players

# Run the fixed pipeline
df_kicks, df_punts, players_meta = load_and_process_all()

# ==========================================
# 3. AXIAL ATTENTION ARCHITECTURE
# ==========================================
class AxialAttentionRanker(nn.Module):
    def __init__(self, n_features, d_model=64, n_heads=4):
        super().__init__()
        self.embedding = nn.Linear(n_features, d_model)
        self.col_attn = nn.MultiheadAttention(d_model, n_heads, batch_first=True)
        self.row_attn = nn.MultiheadAttention(d_model, n_heads, batch_first=True)
        self.norm = nn.LayerNorm(d_model)
        self.rank_head = nn.Sequential(nn.Linear(d_model, 1), nn.Sigmoid())

    def forward(self, x):
        x = self.embedding(x)
        # Column Attention (Inter-feature)
        res = x
        x, _ = self.col_attn(x, x, x)
        x = self.norm(x + res)
        # Row Attention (Inter-play history)
        res = x
        x, _ = self.row_attn(x, x, x)
        x = self.norm(x + res)
        return self.rank_head(x.mean(dim=1))

# ==========================================
# 4. TENSOR PREPARATION & TRAINING
# ==========================================
def prepare_and_train(df, feature_cols, target_col):
    # Tensor Creation
    kicker_groups = df.groupby('kickerId')
    tensors, labels = [], []
    for k_id, group in kicker_groups:
        feats = group[feature_cols].fillna(0).values
        if len(feats) > 50: feats = feats[:50]
        else: feats = np.vstack([feats, np.zeros((50-len(feats), len(feature_cols)))])
        tensors.append(feats)
        labels.append(group[target_col].mean())

    X = torch.nan_to_num(torch.FloatTensor(np.array(tensors)))
    y = torch.nan_to_num(torch.FloatTensor(labels))

    # Normalization
    X = (X - X.mean(dim=(0,1))) / (X.std(dim=(0,1)) + 1e-6)

    # Train
    model = AxialAttentionRanker(n_features=len(feature_cols))
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MarginRankingLoss(margin=0.1)

    for epoch in range(50):
        optimizer.zero_grad()
        idx = torch.randperm(X.size(0))
        mid = len(idx)//2
        a, b = idx[:mid], idx[mid:2*mid]
        s_a, s_b = model(X[a]).squeeze(), model(X[b]).squeeze()
        target = torch.where(y[a] > y[b], 1.0, -1.0)
        loss = criterion(s_a, s_b, target)
        loss.backward()
        optimizer.step()

    return model, X, kicker_groups.first().index

# Run for both
print("Training Kicker Model...")
k_model, k_X, k_ids = prepare_and_train(df_kicks, ['kickLength', 'kick_angle', 'operationTime', 'poe'], 'poe')
print("Training Punter Model...")
p_model, p_X, p_ids = prepare_and_train(df_punts, ['kickLength', 'hangTime', 'operationTime', 'fpoe'], 'fpoe')

# ==========================================
# 5. FINAL RANKINGS
# ==========================================
def get_final_table(model, X, ids, meta):
    scores = model(X).detach().numpy().flatten()
    res = pd.DataFrame({'nflId': ids, 'Score': scores})
    res = res.merge(meta[['nflId', 'displayName']], on='nflId')
    return res.sort_values('Score', ascending=False)

kicker_ranks = get_final_table(k_model, k_X, k_ids, players_meta)
punter_ranks = get_final_table(p_model, p_X, p_ids, players_meta)

print("\nTOP KICKERS (Points Over Expected):")
print(kicker_ranks.head(1000))
print("\nTOP PUNTERS (Position Over Expected):")
print(punter_ranks.head(1000))